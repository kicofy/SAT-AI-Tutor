
一、整体架构思路（后端为主）

1.1 核心目标
	•	最高学习效率 = 科学学习方法 + 自适应算法：
	•	诊断 → 能力建模 → 精准刷题 → 间隔复习 → 长期预测分数
	•	纯 AI 教学，无老师：
	•	AI 负责：题库解析、讲解、诊断报告、学习计划生成
	•	中英双语：
	•	题目英文为主
	•	解析/讲解 JSON 中同时放 text_en / text_zh

1.2 后端模块划分（Flask 蓝图）

你可以把后端分成这些逻辑模块：
	•	auth：登录、注册、JWT/Session 管理
	•	student：学生端页面（学习路径、进度）
	•	admin：管理员上传 & 管理题库
	•	question：题库 CRUD & 查询
	•	learning：学习计划 & 自适应出题
	•	ai：所有 LLM 调用统一从这里走（讲解、题库解析、诊断报告）
	•	analytics：统计、预测分数、学习报告

⸻

二、项目目录结构规划

建议目录结构如下（你可以直接照抄改）：

sat_platform/
│
├─ app.py                      # 程序入口
├─ config.py                   # 配置（开发/生产）
├─ requirements.txt
├─ .env                        # 环境变量（API Key 等）
│
├─ sat_app/                    # 主应用包
│  ├─ __init__.py              # create_app 工厂
│  ├─ extensions.py            # SQLAlchemy、JWT、CORS、Migrate等初始化
│  │
│  ├─ models/                  # 数据库模型
│  │  ├─ __init__.py
│  │  ├─ user.py
│  │  ├─ question.py
│  │  ├─ skill.py
│  │  ├─ learning.py
│  │  ├─ analytics.py
│  │
│  ├─ services/                # 业务逻辑层（不直接依赖 Flask）
│  │  ├─ __init__.py
│  │  ├─ ai_client.py          # 调用大模型封装
│  │  ├─ ai_question_parser.py # 题库解析
│  │  ├─ ai_explainer.py       # 讲解协议生成
│  │  ├─ ai_diagnostic.py      # 水平测试 & 诊断报告
│  │  ├─ learning_plan_service.py  # 学习计划生成
│  │  ├─ adaptive_engine.py    # 自适应出题算法
│  │  ├─ score_predictor.py    # SAT 分数预测
│  │  ├─ spaced_repetition.py  # 间隔复习逻辑
│  │
│  ├─ blueprints/              # Flask 蓝图（API 路由）
│  │  ├─ __init__.py
│  │  ├─ auth_bp.py
│  │  ├─ admin_bp.py
│  │  ├─ student_bp.py
│  │  ├─ question_bp.py
│  │  ├─ learning_bp.py
│  │  ├─ ai_bp.py
│  │  ├─ analytics_bp.py
│  │
│  ├─ schemas/                 # Pydantic / marshmallow 序列化 & 校验
│  │  ├─ __init__.py
│  │  ├─ user_schema.py
│  │  ├─ question_schema.py
│  │  ├─ plan_schema.py
│  │  ├─ answer_schema.py
│  │
│  ├─ utils/                   # 工具模块
│  │  ├─ __init__.py
│  │  ├─ file_parser.py        # 提取PDF/Word文本
│  │  ├─ text_normalizer.py
│  │  ├─ security.py
│  │  ├─ time_utils.py
│  │
│  └─ tasks/ (可选)            # 异步任务（如用 RQ/Celery）
│     ├─ __init__.py
│     ├─ question_tasks.py     # 异步题库解析、打标
│
└─ migrations/                 # 数据库迁移

app.py 非常简单，只做一件事：从 sat_app 创建 app 并运行。

⸻

三、app.py & __init__.py 结构

3.1 app.py

from sat_app import create_app

app = create_app()

if __name__ == "__main__":
    app.run(debug=True)

3.2 sat_app/init.py

from flask import Flask
from .extensions import db, migrate, jwt, cors
from .blueprints.auth_bp import auth_bp
from .blueprints.admin_bp import admin_bp
from .blueprints.student_bp import student_bp
from .blueprints.question_bp import question_bp
from .blueprints.learning_bp import learning_bp
from .blueprints.ai_bp import ai_bp
from .blueprints.analytics_bp import analytics_bp
from . import models  # 导入模型以便注册到 SQLAlchemy

def create_app(config_name=None):
    app = Flask(__name__)
    app.config.from_object("config.DevConfig" if config_name is None else config_name)

    # init extensions
    db.init_app(app)
    migrate.init_app(app, db)
    jwt.init_app(app)
    cors.init_app(app)

    # register blueprints
    app.register_blueprint(auth_bp, url_prefix="/api/auth")
    app.register_blueprint(admin_bp, url_prefix="/api/admin")
    app.register_blueprint(student_bp, url_prefix="/api/student")
    app.register_blueprint(question_bp, url_prefix="/api/question")
    app.register_blueprint(learning_bp, url_prefix="/api/learning")
    app.register_blueprint(ai_bp, url_prefix="/api/ai")
    app.register_blueprint(analytics_bp, url_prefix="/api/analytics")

    return app


⸻

四、数据模型设计（高效学习的基础）

4.1 用户 & 学习状态

sat_app/models/user.py：
	•	User
	•	id, email, password_hash, role (student/admin), created_at
	•	UserProfile
	•	user_id (OneToOne)
	•	target_score_rw, target_score_math, exam_date
	•	daily_available_minutes（每天可学习时间）
	•	language_preference (en, zh, bilingual)

4.2 题库 & 技能

sat_app/models/question.py：
	•	Passage（阅读/写作文章）
	•	id, content_text, metadata(json)
	•	Question
	•	id, section (RW/Math), sub_section
	•	passage_id (nullable)
	•	stem_text
	•	choices(json)  // A,B,C,D
	•	correct_answer(json)
	•	difficulty_level (1–5)
	•	irt_a, irt_b（可为空）
	•	skill_tags(json)
	•	estimated_time_sec
	•	source, page, index_in_set
	•	QuestionSet
	•	用于整卷、水平测试卷：name, description, type(diagnostic,practice)

4.3 学习日志 & 能力建模

sat_app/models/learning.py：
	•	UserQuestionLog
	•	id, user_id, question_id
	•	is_correct(bool)
	•	user_answer(json)
	•	time_spent_sec
	•	answered_at
	•	viewed_explanation (bool)
	•	SkillMastery
	•	user_id, skill_tag
	•	mastery_score (0–1)
	•	last_practiced_at
	•	success_streak
	•	StudyPlan
	•	user_id
	•	plan_date
	•	target_minutes
	•	target_questions
	•	generated_detail (json: 包含“上午做哪类题、晚上做哪类题”等)
	•	StudySession
	•	id, user_id
	•	start_time, end_time
	•	questions_assigned (json)
	•	questions_done (json)
	•	summary (json)

⸻

五、AI 模块设计（题库解析 & 讲解协议）

5.1 统一 LLM 客户端 ai_client.py

class AIClient:
    def __init__(self, api_key, model_name):
        self.api_key = api_key
        self.model_name = model_name

    def chat(self, messages, **kwargs):
        """
        封装对 OpenAI / 其他 LLM 的调用
        messages: [{"role":"system","content":"..."}, ...]
        返回：LLM 的 JSON 或文本
        """
        # TODO: 实现具体调用
        pass

# 提供全局单例
ai_client = AIClient(api_key="...", model_name="gpt-4.1")  # 示例

5.2 题库解析服务 ai_question_parser.py

负责：管理员上传 PDF/Word → 提取文本 → 调用 LLM → 标准题目结构。
	•	函数示例：

def parse_raw_question_block(raw_text: str) -> dict:
    """
    输入：从 PDF/Word 中切分出的一个题块文本
    输出：符合 Question 标准结构的 dict
    """
    prompt = build_question_parse_prompt(raw_text)
    result = ai_client.chat(prompt)
    # 解析 result JSON，返回 dict

提示词里要求 LLM 输出：
	•	stem_text
	•	choices
	•	correct_answer
	•	difficulty_level（模型预估）
	•	skill_tags

5.3 讲解协议服务 ai_explainer.py

使用我们之前设计的 JSON 讲解协议，你只需要把那套 schema 固化：

def explain_question(question: Question, user_answer, user_language, depth="standard") -> dict:
    payload = build_explain_prompt(question, user_answer, user_language, depth)
    response_json = ai_client.chat(payload)
    # 校验 JSON 结构（用 pydantic/marshmallow），再返回
    return response_json

Prompt 要求 LLM：
	•	必须返回固定 JSON 字段： protocol_version, question_id, answer_correct, explanation_blocks 等
	•	explanation_blocks 中包含 text_en / text_zh & related_parts 方便前端高亮

5.4 诊断 & 报告 ai_diagnostic.py

你可以同时使用：
	•	统计学规则（正确率 + 难度）
	•	LLM 生成“人话”报告：“你在函数理解方面已经接近 600 分水平…”

⸻

六、学习计划 & 自适应引擎（“最高效率”的核心）

6.1 学习理论组合

尽量贴近研究结论：
	1.	诊断 + Mastery Learning：
	•	对每个 skill 建立 0–1 的掌握度 mastery_score
	•	当掌握度 < 阈值（例如 0.7）集中强化
	2.	自适应难度：
	•	难度略高于当前能力（“可接受挫败感”）
	3.	间隔复习 (Spaced Repetition)：
	•	错题不是迅速刷一堆，而是间隔几天循环回顾
	4.	交错练习 (Interleaving)：
	•	一次练习中不要只刷一种题型，穿插 2–3 个相关 skill

6.2 自适应出题引擎 adaptive_engine.py

核心函数：select_next_questions(user_id, n_questions) -> List[Question]

伪代码逻辑：

def select_next_questions(user_id, n_questions=10):
    # 1. 读取用户技能掌握度
    mastery = load_user_mastery(user_id)  # dict {skill_tag: mastery_score}

    # 2. 计算每个 skill 的“训练优先级”
    #   越不熟 → 评分越高；长时间没练 → 评分再加权
    skill_priorities = {}
    for skill, m_score in mastery.items():
        correct_gap = 1.0 - m_score         # 掌握度差距
        days_since_last = days_from_last_practice(user_id, skill)
        recency_factor = min(days_since_last / 7.0, 1.5)  # 最多加 1.5 倍
        priority = 0.6 * correct_gap + 0.4 * recency_factor
        skill_priorities[skill] = priority

    # 3. 选出若干最高 priority 的 skill（比如前 3）
    top_skills = pick_top_k(skill_priorities, k=3)

    # 4. 在这些 skill 对应题库中，选难度接近用户水平的题
    questions = []
    for skill in top_skills:
        target_level = estimate_user_difficulty_level(user_id, skill)
        candidates = query_questions_by_skill_and_difficulty(skill, target_level)
        questions.extend(sample_questions(candidates, n_questions_per_skill))

    # 5. 插入一部分错题回顾
    review_questions = select_due_review_questions(user_id, limit=2)
    questions = merge_and_shuffle(questions, review_questions)

    return questions[:n_questions]

6.3 学习计划生成 learning_plan_service.py

入口函数：generate_daily_plan(user_id, date_today) -> StudyPlan

考虑因素：
	•	用户每天可学习时间 daily_available_minutes（用户设置）
	•	离考试日期剩余天数
	•	当前预测分数 vs 目标分数差距

计划内容设计
StudyPlan.generated_detail 示例：

{
  "date": "2025-12-02",
  "total_minutes": 60,
  "blocks": [
    {
      "start": "evening",
      "duration": 20,
      "focus": "Math - linear equations",
      "question_count": 8
    },
    {
      "start": "evening",
      "duration": 20,
      "focus": "RW - grammar & sentence structure",
      "question_count": 8
    },
    {
      "start": "evening",
      "duration": 20,
      "focus": "Review - past mistakes",
      "question_count": 6
    }
  ]
}

生成算法示例：

def generate_daily_plan(user_id, date_today):
    profile = UserProfile.query.filter_by(user_id=user_id).first()
    available_minutes = profile.daily_available_minutes or 60

    # 1. 获取 skill 优先级（见上）
    skill_priorities = calculate_skill_priorities(user_id)

    # 2. 按 RW 与 Math 平衡拆分时间（例如 50/50 或根据当前偏科情况动态调整）
    rw_need, math_need = estimate_section_gap(user_id)
    # 比如：Math 更差 → 给 Math 分配60%，RW 40%

    # 3. 生成 blocks：Math 强化 + RW 强化 + 错题回顾
    blocks = build_blocks_by_time_and_priority(
        total_minutes=available_minutes,
        rw_need=rw_need,
        math_need=math_need,
        skill_priorities=skill_priorities
    )

    plan = StudyPlan(
        user_id=user_id,
        plan_date=date_today,
        target_minutes=available_minutes,
        target_questions=sum(b["question_count"] for b in blocks),
        generated_detail=blocks
    )
    db.session.add(plan)
    db.session.commit()
    return plan

这样你的平台每天可以自动给用户推一个「最合理的刷题组合」：
	•	重点补短板
	•	同时维护强项
	•	带有错题回顾

⸻

七、重要 API 规划

只列出核心（都可 REST 风格）。

7.1 学生端
	•	POST /api/auth/register，POST /api/auth/login
	•	GET /api/student/me：个人信息 & 当前预测分数 & 目标分数
	•	GET /api/learning/plan/today：获取今日学习计划
	•	POST /api/learning/session/start：开始一轮练习，返回题目列表
	•	POST /api/learning/session/answer
	•	Body：question_id, user_answer, time_spent…
	•	返回：是否正确 + 调用 AI 讲解（或仅返回讲解 ID）
	•	GET /api/analytics/progress：折线图数据，预测分数变化

7.2 管理员端
	•	POST /api/admin/questions/upload
	•	上传 PDF/Word，后台拆分为多个原始题块
	•	POST /api/admin/questions/parse
	•	触发 AI 解析（可异步）
	•	GET /api/admin/questions：分页查看题目
	•	PUT /api/admin/question/{id}：修改题目 & 标记 skill_tags 等

7.3 AI 接口（内部用）
	•	POST /api/ai/explain
	•	输入：question_id, user_answer, language_pref
	•	输出：讲解协议 JSON（前端直接渲染）
	•	POST /api/ai/diagnose
	•	输入：水平测试作答记录
	•	输出：skill 能力估计 + 预测分数 + 文本报告

⸻

八、配置 & 环境

config.py 示例：

class BaseConfig:
    SQLALCHEMY_TRACK_MODIFICATIONS = False
    JWT_SECRET_KEY = "change_me"
    AI_MODEL_NAME = "gpt-4.1"
    AI_API_KEY = "..."

class DevConfig(BaseConfig):
    SQLALCHEMY_DATABASE_URI = "postgresql://user:pwd@localhost/sat_dev"
    DEBUG = True

class ProdConfig(BaseConfig):
    SQLALCHEMY_DATABASE_URI = "postgresql://user:pwd@prod-db/sat_prod"
    DEBUG = False


⸻

九、推荐开发顺序（一步步落地）
	1.	基础骨架
	•	app.py + create_app
	•	extensions（db, jwt, migrate）
	•	User / Auth 蓝图先写好
	2.	数据模型 & 迁移
	•	User, Question, Skill, UserQuestionLog, SkillMastery, StudyPlan
	3.	管理员题库上传 + 手动录入题目接口（先不接 AI，也能跑）
	4.	基础刷题 + 答案记录
	•	POST /session/start → 随机给题
	•	POST /session/answer → 判分 & 记录日志
	5.	接入 AI 讲解协议
	•	实现 ai_explainer.py 和 /api/ai/explain
	•	前端根据 JSON 做高亮 & 中英切换
	6.	实现简易自适应 & 学习计划
	•	adaptive_engine 基于正确率
	•	learning_plan_service 基于时间 & 目标
	7.	水平测试 & 预测分数
	8.	后面再逐步优化：IRT、题库解析自动化、可视化报告等。

