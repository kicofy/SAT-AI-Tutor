# Step 04 â€“ Database Migrations and Seeding

## Goal
Wire up Flask-Migrate, generate the initial schema (users + profiles), and provide reproducible data seeding so future steps build on a stable database foundation.

## Dependencies
- Step 03 (user models and auth logic)

## Detailed Tasks
1. Configure `flask` CLI entry point (via `FLASK_APP=app.py`) and ensure `Migrate` is initialized with the app and `db`.
2. Run `flask db init` to create the `migrations/` directory structure.
3. Generate the first migration (`flask db migrate -m "create users"`) capturing `User` and `UserProfile`.
4. Review and, if needed, edit the autogenerated migration scripts to ensure constraints/indexes are correct (unique email, foreign keys).
5. Apply migrations locally (`flask db upgrade`) and verify tables exist via `psql` or SQLAlchemy inspector.
6. Implement a lightweight seeding script/CLI command (e.g., `sat_app/cli/seed.py`) to insert:
   - An initial admin user (configurable password via env variable).
   - Sample student user with profile data for testing.
7. Document migration workflow in `README.md` (init, migrate, upgrade, downgrade).
8. Optionally add a GitHub Action or pre-commit hook to run `flask db migrate --check` in CI to ensure models and migrations stay aligned.

## Deliverables
- `migrations/` directory with initial revision.
- Repeatable database upgrade/downgrade instructions.
- Seed command or script populating essential baseline data.

## Verification
- Dropping and recreating the database followed by `flask db upgrade` rebuilds schema without manual edits.
- Running the seed script creates the admin user visible via SQL query or Auth API login.
- `flask db current` shows the expected revision hash.

## Notes
- Keep seeds minimal; richer fixtures can be added later for question banks and study data.

